index.html <!doctype html> <html lang="vi"> <head> <meta charset="utf-8" /> <meta name="viewport" content="width=device-width,initial-scale=1" /> <title>S√¢uüêõGPT</title> <link rel="stylesheet" href="style.css" /> </head> <body> <header> <button id="hamburger" aria-label="menu">‚ò∞</button> <div class="brand"> <span class="icon">üêõ</span> <span class="title">S√¢u<span class="tiny">GPT</span></span> </div> <div class="top-actions"> <button id="btnNickname">ƒê·∫∑t bi·ªát danh</button> </div> </header> <div class="layout"> <aside id="sidebar" class="collapsed"> <div class="side-top"> <h2>üêõ S√¢uGPT</h2> <button id="btnNewChat" class="primary">+ ƒêo·∫°n chat m·ªõi</button> </div> <nav class="menu"> <a href="#" class="menu-item" id="m-nickname">ƒê·∫∑t bi·ªát danh</a> <a href="#" class="menu-item" id="m-export">Xu·∫•t chat</a> <a href="#" class="menu-item" id="m-help">Tr·ª£ gi√∫p</a> <a href="#" class="menu-item" id="m-settings">C√†i ƒë·∫∑t</a> </nav> </aside> <main> <section class="hero"> <h1>T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n?</h1> <p class="subtitle">T√¥i l√† tr·ª£ l√Ω AI th√¥ng minh <strong id="botNamePreview">S√¢uGPT</strong>, s·∫µn s√†ng h·ªó tr·ª£ b·∫°n.</p> </section> <section id="chatArea"> <div id="chat" class="chat"></div> </section> <section class="composer"> <div class="left-tools"> <label class="image-btn"> <input id="imageInput" type="file" accept="image/*" /> üì∑ </label> </div> <input id="userInput" placeholder="H·ªèi b·∫•t k·ª≥ ƒëi·ªÅu g√¨..." autocomplete="off" /> <button id="sendBtn" class="send">‚ñ∂</button> </section> </main> </div> <!-- Modal ƒë·∫∑t bi·ªát danh --> <div id="nickModal" class="modal hidden"> <div class="modal-card"> <h3>ƒê·∫∑t bi·ªát danh</h3> <label> T√™n S√¢uGPT (t√™n hi·ªÉn th·ªã bot):</label> <input id="botName" placeholder="V√≠ d·ª•: S√¢uüêõGPT" /> <label> B·∫°n mu·ªën ƒë∆∞·ª£c g·ªçi l√†:</label> <input id="userAlias" placeholder="T√™n b·∫°n hi·ªÉn th·ªã" /> <div class="modal-actions"> <button id="saveNick" class="primary">L∆∞u</button> <button id="cancelNick">H·ªßy</button> </div> </div> </div> <template id="msgTemplate"> <div class="message"> <div class="meta"></div> <div class="content"></div> </div> </template> <script src="script.js"></script> </body> </html> script.js // UI refs const hamburger = document.getElementById("hamburger"); const sidebar = document.getElementById("sidebar"); const btnNewChat = document.getElementById("btnNewChat"); const btnNickname = document.getElementById("btnNickname"); const nickModal = document.getElementById("nickModal"); const botNameInput = document.getElementById("botName"); const userAliasInput = document.getElementById("userAlias"); const saveNick = document.getElementById("saveNick"); const cancelNick = document.getElementById("cancelNick"); const botNamePreview = document.getElementById("botNamePreview"); const chatEl = document.getElementById("chat"); const userInput = document.getElementById("userInput"); const sendBtn = document.getElementById("sendBtn"); const imageInput = document.getElementById("imageInput"); let messages = [{ role: "system", content: "B·∫°n l√† S√¢uGPT, tr·ª£ l√Ω th√¢n thi·ªán, tr·∫£ l·ªùi r√µ r√†ng, c√≥ th·ªÉ vi·∫øt code v√† chia th√†nh block, v√† t√°ch code trong
th√†nh kh·ªëi c√≥ n√∫t sao ch√©p." }]; // load nicknames t·ª´ localStorage function loadNames(){ const bot = localStorage.getItem("saugpt_botname") || "S√¢uGPT"; const alias = localStorage.getItem("saugpt_useralias") || "B·∫°n"; botNamePreview.textContent = bot; botNameInput.value = bot; userAliasInput.value = alias; } loadNames(); // sidebar toggle hamburger.addEventListener("click", ()=> sidebar.classList.toggle("collapsed")); btnNickname.addEventListener("click", ()=> { nickModal.classList.remove("hidden"); }); // modal actions saveNick.addEventListener("click", ()=>{ localStorage.setItem("saugpt_botname", botNameInput.value || "S√¢uGPT"); localStorage.setItem("saugpt_useralias", userAliasInput.value || "B·∫°n"); loadNames(); nickModal.classList.add("hidden"); }); cancelNick.addEventListener("click", ()=> nickModal.classList.add("hidden")); // new chat btnNewChat.addEventListener("click", ()=>{ messages = [{ role: "system", content: "B·∫°n l√† S√¢uGPT, tr·ª£ l√Ω th√¢n thi·ªán, tr·∫£ l·ªùi r√µ r√†ng, c√≥ th·ªÉ vi·∫øt code v√† chia th√†nh block." }]; chatEl.innerHTML = ""; addBotText("Xin ch√†o! M·ªùi b·∫°n nh·∫≠p c√¢u h·ªèi."); }); // helper append message (supports code blocks & copy) function appendMessage(who, text){ const wrapper = document.createElement("div"); wrapper.className = "message " + (who === "user" ? "user" : "bot"); const meta = document.createElement("div"); meta.className = "meta"; const alias = localStorage.getItem("saugpt_useralias") || "B·∫°n"; meta.innerText = who === "user" ? alias + ":" : (localStorage.getItem("saugpt_botname") || "S√¢uGPT") + ":"; const content = document.createElement("div"); content.className = "content"; // parse code blocks
...
-> create <pre> with copy button const parts = text.split(/
/);
  for (let i = 0; i < parts.length; i++){
    if (i % 2 === 0){
      // normal text (may contain newlines)
      const p = document.createElement("div");
      p.innerText = parts[i];
      content.appendChild(p);
    } else {
      // code block
      const pre = document.createElement("pre");
      pre.className = "code-block";
      const code = document.createElement("code");
      code.textContent = parts[i];
      pre.appendChild(code);

      const copyBtn = document.createElement("button");
      copyBtn.className = "copy-btn";
      copyBtn.textContent = "Sao ch√©p";
      copyBtn.addEventListener("click", async ()=>{
        await navigator.clipboard.writeText(code.textContent);
        copyBtn.textContent = "ƒê√£ sao ch√©p!";
        setTimeout(()=> copyBtn.textContent = "Sao ch√©p", 1500);
      });
      pre.appendChild(copyBtn);
      content.appendChild(pre);
    }
  }

  wrapper.appendChild(meta);
  wrapper.appendChild(content);
  chatEl.appendChild(wrapper);
  chatEl.scrollTop = chatEl.scrollHeight;
}

// add quick messages
function addUserText(txt){
  appendMessage("user", txt);
}
function addBotText(txt){
  appendMessage("bot", txt);
}

// typing indicator (dots) while waiting
function addTypingIndicator(){
  const div = document.createElement("div");
  div.className = "message bot typing";
  div.innerHTML = `<div class="meta">${localStorage.getItem("saugpt_botname") || "S√¢uGPT"}:</div>
                   <div class="content"><span class="typing-dots"><span></span><span></span><span></span></span></div>`;
  chatEl.appendChild(div);
  chatEl.scrollTop = chatEl.scrollHeight;
  return div;
}

// remove typing indicator
function removeTypingIndicator(el){
  if(el && el.parentNode) el.parentNode.removeChild(el);
}

// send message to server
async function sendMessage(text, base64Image){
  // push to history
  messages.push({ role:"user", content: text });

  // show typing
  const typingEl = addTypingIndicator();

  try {
    // send messages only (do not send large image). If you want to send image, convert to link or mention it in text.
    const resp = await fetch("/chat", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ messages })
    });

    if (!resp.ok){
      const err = await resp.text();
      removeTypingIndicator(typingEl);
      addBotText("‚ö†Ô∏è C√≥ l·ªói x·∫£y ra (API Key sai ho·∫∑c server l·ªói).");
      console.error("Server non-OK:", resp.status, err);
      return;
    }

    const data = await resp.json();
    // choose message text path for responses from OpenAI (compatibility)
    const reply = (data.choices && data.choices[0] && (data.choices[0].message?.content || data.choices[0].text)) || data.output_text || "Kh√¥ng c√≥ ph·∫£n h·ªìi.";
    removeTypingIndicator(typingEl);

    // typing effect reveal character by character
    await renderWithTypingEffect(reply);
    messages.push({ role:"assistant", content: reply });
  } catch (e){
    removeTypingIndicator(typingEl);
    addBotText("‚ö†Ô∏è L·ªói server. Vui l√≤ng th·ª≠ l·∫°i");
    console.error(e);
  }
}

// show reply with typing effect & support code blocks
async function renderWithTypingEffect(fullText){
  // we will produce char-by-char but keep code blocks intact (no char typing inside code)
  const segments = fullText.split(/(
[\s\S]*?
)/g); // keep code blocks whole
  for (let seg of segments){
    if (!seg) continue;
    if (seg.startsWith("
")){ // code block - append whole block at once (without the backticks) const codeContent = seg.replace(/^
/, "").replace(/
$/, ""); appendMessage("bot", "
" + codeContent + "
"); } else { // normal text - reveal char by char let acc = ""; const partialWrap = document.createElement("div"); partialWrap.className = "message bot"; partialWrap.innerHTML = <div class="meta">${localStorage.getItem("saugpt_botname") || "S√¢uGPT"}:</div><div class="content"></div>; chatEl.appendChild(partialWrap); const contentDiv = partialWrap.querySelector(".content"); for (let i=0;i<seg.length;i++){ acc += seg[i]; contentDiv.textContent = acc; chatEl.scrollTop = chatEl.scrollHeight; await new Promise(r => setTimeout(r, 6 + Math.random()*6)); // speed } } } } // UI events sendBtn.addEventListener("click", async ()=>{ const txt = userInput.value.trim(); const file = imageInput.files[0]; if(!txt && !file) return; // if image chosen, show preview and treat separately if (file){ const base64 = await toBase64(file); // show user's image appendMessage("user", "[H√¨nh ·∫£nh g·ª≠i k√®m]"); const img = document.createElement("img"); img.src = base64; img.style.maxWidth = "240px"; img.style.display="block"; img.style.marginTop="8px"; const last = chatEl.lastElementChild; last.querySelector(".content").appendChild(img); // optionally: add a note to message text so the bot knows user sent an image const note = txt ? txt + " (k√®m h√¨nh ·∫£nh g·ª≠i ·ªü tr√™n)" : "(k√®m h√¨nh ·∫£nh)"; userInput.value = ""; imageInput.value = ""; addUserText(note); await sendMessage(note, base64); return; } addUserText(txt); userInput.value = ""; await sendMessage(txt, null); }); // support enter key userInput.addEventListener("keydown", (e)=>{ if (e.key === "Enter" && !e.shiftKey){ e.preventDefault(); sendBtn.click(); } }); // helper base64 function toBase64(file){ return new Promise((res, rej)=>{ const fr = new FileReader(); fr.onload = ()=> res(fr.result); fr.onerror = rej; fr.readAsDataURL(file); }); } // initial greeting (function init(){ const bot = localStorage.getItem("saugpt_botname") || "S√¢uGPT"; addBotText(Xin ch√†o! T√¥i l√† ${bot} ‚Äî h·ªèi g√¨ m√¨nh gi√∫p nh√©.); })(); style.css // UI refs const hamburger = document.getElementById("hamburger"); const sidebar = document.getElementById("sidebar"); const btnNewChat = document.getElementById("btnNewChat"); const btnNickname = document.getElementById("btnNickname"); const nickModal = document.getElementById("nickModal"); const botNameInput = document.getElementById("botName"); const userAliasInput = document.getElementById("userAlias"); const saveNick = document.getElementById("saveNick"); const cancelNick = document.getElementById("cancelNick"); const botNamePreview = document.getElementById("botNamePreview"); const chatEl = document.getElementById("chat"); const userInput = document.getElementById("userInput"); const sendBtn = document.getElementById("sendBtn"); const imageInput = document.getElementById("imageInput"); let messages = [{ role: "system", content: "B·∫°n l√† S√¢uGPT, tr·ª£ l√Ω th√¢n thi·ªán, tr·∫£ l·ªùi r√µ r√†ng, c√≥ th·ªÉ vi·∫øt code v√† chia th√†nh block, v√† t√°ch code trong
th√†nh kh·ªëi c√≥ n√∫t sao ch√©p." }]; // load nicknames t·ª´ localStorage function loadNames(){ const bot = localStorage.getItem("saugpt_botname") || "S√¢uGPT"; const alias = localStorage.getItem("saugpt_useralias") || "B·∫°n"; botNamePreview.textContent = bot; botNameInput.value = bot; userAliasInput.value = alias; } loadNames(); // sidebar toggle hamburger.addEventListener("click", ()=> sidebar.classList.toggle("collapsed")); btnNickname.addEventListener("click", ()=> { nickModal.classList.remove("hidden"); }); // modal actions saveNick.addEventListener("click", ()=>{ localStorage.setItem("saugpt_botname", botNameInput.value || "S√¢uGPT"); localStorage.setItem("saugpt_useralias", userAliasInput.value || "B·∫°n"); loadNames(); nickModal.classList.add("hidden"); }); cancelNick.addEventListener("click", ()=> nickModal.classList.add("hidden")); // new chat btnNewChat.addEventListener("click", ()=>{ messages = [{ role: "system", content: "B·∫°n l√† S√¢uGPT, tr·ª£ l√Ω th√¢n thi·ªán, tr·∫£ l·ªùi r√µ r√†ng, c√≥ th·ªÉ vi·∫øt code v√† chia th√†nh block." }]; chatEl.innerHTML = ""; addBotText("Xin ch√†o! M·ªùi b·∫°n nh·∫≠p c√¢u h·ªèi."); }); // helper append message (supports code blocks & copy) function appendMessage(who, text){ const wrapper = document.createElement("div"); wrapper.className = "message " + (who === "user" ? "user" : "bot"); const meta = document.createElement("div"); meta.className = "meta"; const alias = localStorage.getItem("saugpt_useralias") || "B·∫°n"; meta.innerText = who === "user" ? alias + ":" : (localStorage.getItem("saugpt_botname") || "S√¢uGPT") + ":"; const content = document.createElement("div"); content.className = "content"; // parse code blocks
...
-> create <pre> with copy button const parts = text.split(/
/);
  for (let i = 0; i < parts.length; i++){
    if (i % 2 === 0){
      // normal text (may contain newlines)
      const p = document.createElement("div");
      p.innerText = parts[i];
      content.appendChild(p);
    } else {
      // code block
      const pre = document.createElement("pre");
      pre.className = "code-block";
      const code = document.createElement("code");
      code.textContent = parts[i];
      pre.appendChild(code);

      const copyBtn = document.createElement("button");
      copyBtn.className = "copy-btn";
      copyBtn.textContent = "Sao ch√©p";
      copyBtn.addEventListener("click", async ()=>{
        await navigator.clipboard.writeText(code.textContent);
        copyBtn.textContent = "ƒê√£ sao ch√©p!";
        setTimeout(()=> copyBtn.textContent = "Sao ch√©p", 1500);
      });
      pre.appendChild(copyBtn);
      content.appendChild(pre);
    }
  }

  wrapper.appendChild(meta);
  wrapper.appendChild(content);
  chatEl.appendChild(wrapper);
  chatEl.scrollTop = chatEl.scrollHeight;
}

// add quick messages
function addUserText(txt){
  appendMessage("user", txt);
}
function addBotText(txt){
  appendMessage("bot", txt);
}

// typing indicator (dots) while waiting
function addTypingIndicator(){
  const div = document.createElement("div");
  div.className = "message bot typing";
  div.innerHTML = `<div class="meta">${localStorage.getItem("saugpt_botname") || "S√¢uGPT"}:</div>
                   <div class="content"><span class="typing-dots"><span></span><span></span><span></span></span></div>`;
  chatEl.appendChild(div);
  chatEl.scrollTop = chatEl.scrollHeight;
  return div;
}

// remove typing indicator
function removeTypingIndicator(el){
  if(el && el.parentNode) el.parentNode.removeChild(el);
}

// send message to server
async function sendMessage(text, base64Image){
  // push to history
  messages.push({ role:"user", content: text });

  // show typing
  const typingEl = addTypingIndicator();

  try {
    // send messages only (do not send large image). If you want to send image, convert to link or mention it in text.
    const resp = await fetch("/chat", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ messages })
    });

    if (!resp.ok){
      const err = await resp.text();
      removeTypingIndicator(typingEl);
      addBotText("‚ö†Ô∏è C√≥ l·ªói x·∫£y ra (API Key sai ho·∫∑c server l·ªói).");
      console.error("Server non-OK:", resp.status, err);
      return;
    }

    const data = await resp.json();
    // choose message text path for responses from OpenAI (compatibility)
    const reply = (data.choices && data.choices[0] && (data.choices[0].message?.content || data.choices[0].text)) || data.output_text || "Kh√¥ng c√≥ ph·∫£n h·ªìi.";
    removeTypingIndicator(typingEl);

    // typing effect reveal character by character
    await renderWithTypingEffect(reply);
    messages.push({ role:"assistant", content: reply });
  } catch (e){
    removeTypingIndicator(typingEl);
    addBotText("‚ö†Ô∏è L·ªói server. Vui l√≤ng th·ª≠ l·∫°i");
    console.error(e);
  }
}

// show reply with typing effect & support code blocks
async function renderWithTypingEffect(fullText){
  // we will produce char-by-char but keep code blocks intact (no char typing inside code)
  const segments = fullText.split(/(
[\s\S]*?
)/g); // keep code blocks whole
  for (let seg of segments){
    if (!seg) continue;
    if (seg.startsWith("
")){ // code block - append whole block at once (without the backticks) const codeContent = seg.replace(/^
/, "").replace(/
$/, ""); appendMessage("bot", "
" + codeContent + "
"); } else { // normal text - reveal char by char let acc = ""; const partialWrap = document.createElement("div"); partialWrap.className = "message bot"; partialWrap.innerHTML = <div class="meta">${localStorage.getItem("saugpt_botname") || "S√¢uGPT"}:</div><div class="content"></div>; chatEl.appendChild(partialWrap); const contentDiv = partialWrap.querySelector(".content"); for (let i=0;i<seg.length;i++){ acc += seg[i]; contentDiv.textContent = acc; chatEl.scrollTop = chatEl.scrollHeight; await new Promise(r => setTimeout(r, 6 + Math.random()*6)); // speed } } } } // UI events sendBtn.addEventListener("click", async ()=>{ const txt = userInput.value.trim(); const file = imageInput.files[0]; if(!txt && !file) return; // if image chosen, show preview and treat separately if (file){ const base64 = await toBase64(file); // show user's image appendMessage("user", "[H√¨nh ·∫£nh g·ª≠i k√®m]"); const img = document.createElement("img"); img.src = base64; img.style.maxWidth = "240px"; img.style.display="block"; img.style.marginTop="8px"; const last = chatEl.lastElementChild; last.querySelector(".content").appendChild(img); // optionally: add a note to message text so the bot knows user sent an image const note = txt ? txt + " (k√®m h√¨nh ·∫£nh g·ª≠i ·ªü tr√™n)" : "(k√®m h√¨nh ·∫£nh)"; userInput.value = ""; imageInput.value = ""; addUserText(note); await sendMessage(note, base64); return; } addUserText(txt); userInput.value = ""; await sendMessage(txt, null); }); // support enter key userInput.addEventListener("keydown", (e)=>{ if (e.key === "Enter" && !e.shiftKey){ e.preventDefault(); sendBtn.click(); } }); // helper base64 function toBase64(file){ return new Promise((res, rej)=>{ const fr = new FileReader(); fr.onload = ()=> res(fr.result); fr.onerror = rej; fr.readAsDataURL(file); }); } // initial greeting (function init(){ const bot = localStorage.getItem("saugpt_botname") || "S√¢uGPT"; addBotText(Xin ch√†o! T√¥i l√† ${bot} ‚Äî h·ªèi g√¨ m√¨nh gi√∫p nh√©.); })(); ch·ªânh tr√™n m·∫•y c√°i n√†y l√†m sao m√† cho m√† gi·ªëng open ai nh·∫•t c√≥ th·ªÉ hehe
